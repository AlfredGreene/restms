RestMS provides web applications with enterprise-level messaging via an asynchronous RESTful interface that works over standard HTTP/HTTPS.  This document is a guide to using RestMS in applications, for RestMS users.

* Name: 9-RESTMS-USER@wiki.amqp.org
* Version: draft/3
* Editor: Pieter Hintjens <ph@imatix.com>
* Contributors: Steve Vinoski <vinoski@ieee.org>, Brad Clements <bkc@murkworks.com>
* Resources: http://www.restms.org.

++ License

This document is licensed under the [http://wiki.amqp.org/main:intellectual-property-policy Intellectual Property Policy] of the wiki.amqp.org site.

++ Change process

This document is governed by the 1-COSS@wiki.amqp.org specification[((bibcite coss))]

++ Goals and structure of this document

This document is a guide for developers who wish to learn and use RestMS in their applications.  We cover:

# A set of worked examples in a high-level programming language;
# The HTTP requests and responses for the worked examples;
# A summary of the methods that RestMS understands;
# A summary of the resources that RestMS supports;
# A proposal for a standardized high-level class API;

The specification is described in more detail by these separate documents:

* [[[spec:10|RestMS-base]]] - generic RESTful framework for documents and methods, for RestMS implementors.
* [[[spec:11|RestMS-core]]] - technical specifications of RestMS, for RestMS implementors.
* [[[spec:12|RestMS-amqp]]] - AMQP-to-RestMS interoperability specifications, for RestMS implementors.

++ Worked examples

- show two examples in Perl

++ The 

++ RestMS in brief

+++ Overall operation

RestMS is a client-server protocol that gives a client web application a way to work with resources on a special web server that implements the RestMS protocol.  By properly creating and accessing resources, the client can publish and receive messages, reliably and rapidly.

For application developers, the key features of RestMS are that it:

* works over standard HTTP, using standard HTTP libraries in any language;
* works by sending and receiving structured documents in XML or JSON format;
* uses the HTTP PUT, GET, DELETE, and POST methods to work with resources;
* obeys the rules for a so-called RESTful architecture;
* allows applications to send and receive messages using a modern decoupled architecture inspired by and compatible with AMQP.[((bibcite amqp))]

+++ Structured documents

The general syntax of a RestMS document in XML is:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <|resource-type| |properties|... >
    ...
  </|resource-type|>
</restms>
[[/code]]

The general syntax of a RestMS document in JSON is a direct mapping of the XML format:

[[code]]
{ "restms":
    { "|resource-type|": [ |properties|... ] }
}
[[/code]]

+++ Uniform Resource Identifiers (URIs)

//Public resources// are named and shared by multiple applications.  The URI for a public resource is based on the resource type and name:

[[code]]
/restms/{resource-type}/{resource-name}
[[/code]]

//Private resources// are unnamed and private to individual applications.  The URI for a private resource is generated by the server:

[[code]]
/restms/resource/{resource hash}
[[/code]]

+++ MIME types

When requesting a resource from the server with a GET method, the client application uses the **Accept** header to tell the server what format to use for the resource representation.  RestMS allows two formats, "application/restms+xml" and "application/restms+json".  Here is the basic client request to retrieve an XML formatted resource:

[[code]]
GET /{resource uri} HTTP/1.1
Accept: application/restms+xml
[[/code]]

Here is the basic client request to retrieve a JSON formatted resource:

[[code]]
GET /{resource uri} HTTP/1.1
Accept: application/restms+json
[[/code]]

When sending a resource specification to the server, client applications use an appropriate **Content-Type** header.  Here is the basic client request to create a new resource using an XML specification:

[[code]]
POST /{parent uri} HTTP/1.1
Content-Type: application/restms+xml
Content-Length: {size of content}

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <|resource-type| |properties|... >
    ...
  </|resource-type|>
</restms>
[[/code]]

And here is the basic client request to create a new resource using a JSON specification:

[[code]]
POST /{parent uri} HTTP/1.1
Content-Type: application/restms+xml
Content-Length: {size of content}

{ "restms":
  { "|resource-type|": [ |properties|... ] }
}
[[/code]]

The Content-Type header is also used on GET responses and PUT requests and responses.  The default MIME type, if a suitable Accept or Content-Header is not provided, is "application/restms+xml".

+++ Methods

* GET - retrieve a known resource
* POST - create a new, dynamically named resource
* PUT - edit a known resource
* DELETE - remove a known resource

+++ Create new resource

* Client: POST resource document, Slug to parent resource
* Server: 201 Created or 200 OK, Location: + resource document
* Short form: POST with no resource document, use all defaults.

[[code]]
Client:
-------------------------------------------------
POST /{parent uri} HTTP/1.1
Content-Type: application/restms+xml
Content-Length: {size of content}
Slug: {resource-name}

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource specifications}
  </{resource type}>
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Length: {size of content}
Content-Type: application/restms+xml
Location: http://{hostname}[{port}]/restms/resource/{hash}
Date-Modified: {resource-date}
ETag: {Etag}

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

+++ Retrieve known resource

Unconditional GET:

* Client: GET resource URI
* Server: 200 OK + resource document

Conditional GET:

* Client: GET resource URI, If-None-Match: {ETag}, If-Modified-Since: {date}
* Server: 304 Not Modified.or 200 OK + document

[[code]]
Client:
-------------------------------------------------
GET /{resource uri} HTTP/1.1

Server:
-------------------------------------------------
HTTP/1.1 200 OK
Content-Length: {size of content}
Content-Type: application/restms+xml
Date-Modified: {resource-date}
ETag: {Etag}

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

+++ Modify known resource

Normal update:

* Client: GET resource URI
* Server: 200 OK + resource document
* Client: PUT resource URI + edited document
* Server: 200 OK

Conditional update:

* Client: GET resource URI
* Server: 200 OK + resource document
* Client: PUT resource URI, If-Match: {ETag}, If-Unmodified-Since: {date} + edited document
* Server: 412 Precondition Failed, or 200 OK

[[code]]
Client:
-------------------------------------------------
PUT /{resource uri} HTTP/1.1
Content-Length: {size of content}
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource contents}
  </{resource type}>
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

+++ Delete known resource

Normal delete:

* Client: DELETE resource URI
* Server: 200 OK

Conditional delete:

* Client: DELETE resource URI, If-Match: {ETag}
* Server: 412 Precondition Failed, or 200 OK

[[code]]
Client:
-------------------------------------------------
DELETE /{resource uri} HTTP/1.1
Content-Length: {size of content}
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource contents}
  </{resource type}>
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

++ Feed types

* **fanout**: each message goes to each join.  Addresses are not used.  Join address should be "*".
* **direct**: each message goes to each join with identical address.
* **topic**: each message goes to each join with address that matches message address.
* **headers**: each message goes to each join with headers that match message headers.
* **system**: implementation-specific.
* **rotator**: each message goes to exactly one join, using round-robin distribution.  Addresses are not used.  Join address should be "*".
* **service**: like rotator, but feed is deleted when last join is deleted.

++ Pipe types

* **fifo**: holds messages until deleted, delivers one by one.
* **stream**: holds messages until deleted, delivers as multipart stream.
* **ondemand**: fetches and delivers one message at a time, on demand.  For use with service feeds.

++ RestMS resources

[[code]]
Resource type           Visibility          Lifecycle
----------------        ----------------    ----------------
Domain                  Public              Configured
  |
  o- Feed               Public, private     Configured, dynamic
  |
  o- Pipe               Private             Dynamic
     |
     o- Join            Private             Dynamic
     |
     o- Message         Private             Dynamic
        |
        o- Content      Private             Dynamic
[[/code]]

+++ Domains

Domain description shows public feeds and pipes:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <domain title="{domain description}">
    [ <feed
        title="{feed description}"
        type="{feed-type}"
        license="{license}"
        href="{feed URI}" /> ] ...
    [ <pipe
        title="{pipe description}"
        type="{pipe-type}"
        href="{pipe URI}" /> ] ...
  </domain>
</restms>
[[/code]]

* GET - retrieve domain.
* POST - creates a new feed or pipe within the domain.  Public feeds need "Slug:" header.
* Server creates default domain with URI path "/restms/domain/default"

+++ Feeds

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <feed
    [ type="fanout|direct|topic|headers|service|rotator|system" ]
    [ title="{short title}" ]
    [ license="{license name}" ]
    />
</restms>
[[/code]]

* GET, PUT, DELETE - retrieve, modify, delete feed.
* POST - send message or content to the feed.
* Server creates default feed with URI path "/restms/feed/default" and type "direct"

To create feed, post to domain URI.

+++ Pipes

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="{pipe type}" reply_to="{string}">
    [ <join href="{join URI}" address="{address pattern}" feed="{feed URI}" /> ] ...
    [ <message href="{message URI}" address="{address literal}" /> ] ...
    [ <message href="{message URI}" async="1" /> ]
  </pipe>
</restms>
[[/code]]

* GET, DELETE - retrieve, delete pipe.
* POST - create join for the pipe.

To create pipe, post to domain URI:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="fifo|stream|ondemand" />
</restms>
[[/code]]

+++ Joins

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <join address="{address pattern}" feed="{feed URI}" />
</restms>
[[/code]]

* GET, DELETE - retrieve, delete join.
* Server creates default join for each pipe onto default feed.

To create join, post to pipe URI.

+++ Messages

For RestMS applications:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message
    [ address="{address literal}" ]
    [ reply_to="{address literal}" ]
    [ feed="{originating feed URI}" ] >
    [ <header name="{header name}" value="{header value}" /> ] ...
    [ <content href="{content URI}" ... />
    | <content type="{MIME type} encoding="{encoding}">{content value}</content> ]
  </message> ...
</restms>
[[/code]]

For AMQP interoperability:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message
    [ address="{address literal}" ]
    [ reply_to="{address literal}" ]
    [ feed="{originating feed URI}" ] >
    [ delivery_mode = "{delivery-mode}" ]
    [ priority = "{priority}" ]
    [ correlation_id = "{correlation-id}" ]
    [ expiration = "{expiration}" ]
    [ message_id = "{message-id}" ]
    [ timestamp = "{timestamp}" ]
    [ type = "{type}" ]
    [ user_id = "{user-id}" ]
    [ app_id = "{app-id}" ]
    [ sender_id = "{sender-id}" ]
    [ <header name="{header name}" value="{header value}" /> ] ...
    [ <content href="{content URI}" /> ] ...
  </message> ...
</restms>
[[/code]]

* GET, DELETE - retrieve, delete message.
* POST - create a new content, Content-Type: {MIME-type};type=content, or create new message.

To create a new message, post zero or more contents then post message to feed URI, with all content URIs.

+++ Contents

* GET - retrieve the content.
* DELETE - delete the content.

++ Service request-response scenario

In which requestor send requests to services, and get responses back:

* RestMS service: create public feed with name of service: **POST <feed name="{service-name}" type="service"/> to /restms/domain/default**, create pipe: **POST <pipe/> to /restms/domain/default**, create join from pipe to service feed: **POST <join feed="/restms/feed/{service-name}"/> to /restms/resource/{pipe-hash}**.  Then retrieve message asynclet: **GET /restms/resource/{asynclet-hash}.**  To send response, use reply-to attribute of request and send to default feed: **POST <message address="{reply-to}"/> to /restms/feed/default**.

* RestMS requestor: create pipe: **POST <pipe/> to /restms/domain/default**.  To send request, post to service feed, with service name as address and own pipe as reply-to attribute: **POST <message address="{service-name}" reply_to="/restms/resource/{pipe-hash}" /> to /restms/feed/default.**  Then retrieve message asynclet: **GET /restms/resource/{asynclet-hash}**.

* AMQP service: declare shared service queue: **Queue.Declare queue="{service-name}"**, then **Basic.Consume** on queue.  To send response, use reply-to attribute of requests and send to default exchange: **Basic.Publish exchange="(empty)" routing-key="{reply-to}"**

* AMQP requestor: declare private response queue: **Queue.Declare queue="(empty)" exclusive=1**, then **Basic.Consume** on queue.  To send request, use service name as routing key and send to default exchange: **Basic.Publish exchange="(empty)" routing-key="{service-name}"**

++ Newsfeed publish-subscribe scenario

In which publishers distribute messages to subscribers:

* AMQP publisher: declare topic exchange: **Exchange.Declare name="{feed-name}" type="topic"**, then publish messages to that exchange: **Basic.Publish exchange="{feed-name}" routing-key="{category}"**

* AMQP subscriber: use private queue: **Queue.Declare queue="(empty)" exclusive=1**, then **Basic.Consume** on queue.  To subscribe, bind queue to feed exchange, using category pattern: **Queue.Bind queue="{queue}" exchange="{feed-name}" routing-key="{category pattern}"**

* RestMS publisher: create public feed: **POST <feed name="{feed-name}" type="topic"/> to /restms/domain/default**, then publish messages to that feed: **POST <message address="{category}"/> to /restms/feed/{feed-name}**.

* RestMS subscriber: create pipe: **POST <pipe/> to /restms/domain/default**.  Create join from pipe to feed: **POST <join address="{category pattern}" feed="{feed-name}"/>** Then retrieve message asynclet: **GET /restms/resource/{asynclet-hash}**.




++ Low-level RestMS by example

In this section we implement two typical messaging scenarios using RestMS: a service-oriented network, and a publish-subscribe network.  These examples demonstrate how RestMS works and are useful starting points for real applications.

For the examples, we assume the RestMS server is running on port 80 at host.com, and we show only HTTP headers that are relevant to the example.

+++ Fortune service example

In this example we show how to implement a service that returns a random message, also called a "fortune cookie".  The fortune service works as follows:

* A client sends a request message to a fortune service.
* The fortune service responds with something witty.

Here is the message format used by the fortune service.  The request message takes this form:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message reply_to="{pipe name}" />
</restms>
[[/code]]

And the response message takes this form:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="{request reply-to}">
    <header name="fortune" value="{fortune cookie text}" />
  </message>
</restms>
[[/code]]

Note that in this example we are carrying the message data in the message envelope.  This is useful for short text payloads.  RestMS also lets us carry data as separate "contents", which is useful for larger, or binary payloads.

Message routing for this example works as follows:

* Clients send their requests to a service called "fortune"
* The fortune service responds to the reply-to value of the message.
* In both cases, messages are routed via the //default feed//.

++++ The fortune service

We now explain how the same service would work using RestMS semantics.  First, the fortune service creates a public feed named "fortune", by posting a feed specification to the default domain:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/default
Content-Type: application/restms+xml
Slug: fortune

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <feed type="service" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml
Location: http://host.com/restms/feed/fortune

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <feed type="service" name="fortune" />
</restms>
[[/code]]

The fortune service then creates a pipe:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/default
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="fifo" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml
Location: http://host.com/restms/resource/C4FE

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="fifo" name="RESTMS_C4FE">
    <!-- All pipes are automatically joined to the default feed -->
    <join
        href="http://host.com/restms/resource/BA5F"
        address="RESTMS_C4FE"
        feed="http://host.com/restms/feed/default" />
    <!-- All pipes contain an asynclet for the message -->
    <message
        href="http://host.com/restms/resource/F00D"
        async="1" />
  </pipe>
</restms>
[[/code]]

The fortune service wants to get messages into its pipe, via the service name "fortune".  It thus creates a join from its pipe to the fortune feed, by POSTing a join specification to the pipe URI.

[[code]]
Client:
-------------------------------------------------
POST /restms/resource/C4FE
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <join address="*" feed="http://host.com/restms/feed/fortune" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml
Location: http://host.com/restms/resource/B33F

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <join address="*" feed="http://host.com/restms/feed/fortune" />
</restms>
[[/code]]

The fortune service then retrieves the message asynclet, and thus waits for an incoming message:

[[code]]
Client:
-------------------------------------------------
GET /restms/resource/FOOD
[[/code]]

When a client eventually posts a message to the fortune feed, the RestMS server delivers it to our fortune service, which has been waiting:

[[code]]
Server:
-------------------------------------------------
HTTP/1.1 200 OK
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message
    reply_to="RESTMS_B4B4"
    feed="http://host.com/restms/feed/fortune"
    next="http://host.com/restms/resource/DE55" />
</restms>
[[/code]]

The fortune service then replies with a suitable fortune cookie, by posting a message to the default feed using the reply_to attribute of the request as the address:

[[code]]
Client:
-------------------------------------------------
POST /restms/feed/default
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="RESTMS_B4B4">
    <header
      name="fortune"
      value="Complexity is the swamp, simplicity the mountain top" />
  </message>
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

And the fortune service repeats the process by retrieving the next message asynclet, and thus waiting once more for an incoming message:

[[code]]
Client:
-------------------------------------------------
HTTP/1.1 200 OK
GET /restms/resource/DE55
[[/code]]

When the fortune service decides to end, it deletes its pipe:

[[code]]
Client:
-------------------------------------------------
DELETE /restms/resource/C4FE

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

++++ The fortune client

The fortune client creates a pipe by posting a pipe specification document to the default domain:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/default
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="fifo" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml
Location: http://host.com/restms/resource/B4B4

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="fifo" name="RESTMS_B4B4">
    <join
        href="http://host.com/restms/resource/00DA"
        address="RESTMS_B4B4"
        feed="http://host.com/restms/feed/default" />
    <message
        href="http://host.com/restms/resource/C137"
        async="1" />
  </pipe>
</restms>
[[/code]]

The client posts a message to the fortune feed, specifying the reply_to attribute:

[[code]]
Client:
-------------------------------------------------
POST /restms/feed/fortune
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message reply_to="RESTMS_B4B4" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

The fortune client then retrieves the message asynclet, and thus waits for an incoming message:

[[code]]
Client:
-------------------------------------------------
GET /restms/resource/C137
[[/code]]

And when the fortune service responds, the client gets its reply message from the server:

[[code]]
Server:
-------------------------------------------------
HTTP/1.1 200 OK
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="RESTMS_B4B4">
    <header
      name="fortune"
      value="Complexity is the swamp, simplicity the mountain top" />
  </message>
</restms>
[[/code]]

The fortune client then deletes its pipe:

[[code]]
Client:
-------------------------------------------------
DELETE /restms/resource/B4B4

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

+++ Newsfeed publish-subscribe example

In this example we show how to implement a topic-based newsfeed service that distributes news articles using a hierarchical categorization structure.  The newsfeed service works as follows:

* A news publisher sends a stream of news covering various categories.
* Clients subscribe to and receive messages from specific news categories.

We assume the RestMS server is running on port 80 at host.com, and we show only HTTP headers that are relevant to the example.

Here is the message format for the newsfeed:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="{news category}">
    <header name="title" value="{news item title}" />
    <header name="body" value="{news item body}" />
  </message>
</restms>
[[/code]]

Note that in this example we are carrying the message data in the message envelope.  This is useful for short text payloads.  RestMS also lets us carry data as separate "contents", which is useful for larger, or binary payloads.

As an example we will use this news category tree:

[[code]]
rec
   |
   o- pets
   |  |
   |  o- cats
   |  |
   |  o- dogs
   |
   o- cars
[[/code]]

News categories are written with periods separating each level, like this: "rec.pets.cats".  Subscribers can request specific categories, or use wildcards: '*' specifies any value for one level, '#' specifies any value for any number of levels.

Our sample news stream contains these news items (we show the news category and the item title):

[[code]]
rec.pets.dogs   Montreal: Canine Championship series opens
rec.cars        The oil shock: does it affect you?
rec.pets.dogs   Steroids: the ugly truth from Montreal
rec.pets.cats   Cat vs. dog: facts or fictions?
rec.pets.dogs   Montreal in chaos: winner is a cat!
rec.cars        Red, white, or blue: what it says about you
rec.cars        Parking - who, where, why: a new survey
rec.pets.cats   Superiority: it comes naturally
[[/code]]

You can assume that the order of execution for the publisher and subscriber applications, for the purposes of this example, is:

# Publisher application starts and gets ready to send messages.
# Subscriber application starts and gets ready to receive messages.
# Publisher starts publishing.
# Subscriber receives messages.
# Publisher ends.
# Subscriber ends.

++++ The newsfeed publisher

The news publisher first declares a public topic feed called "newsfeed", by posting a feed specification to the default domain:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/default
Content-Type: application/restms+xml
Slug: newsfeed

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <feed type="topic" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml
Location: http://host.com/restms/feed/newsfeed

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <feed type="topic" name="newsfeed" />
</restms>
[[/code]]

It then publishes a batch of news items to the newsfeed feed (for the example, we're not showing the actual news stories, but in reality these would be in the message envelope, or sent as separate contents):

[[code]]
Client:
-------------------------------------------------
POST /restms/feed/newsfeed
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="rec.pets.dogs">
    <header name="title" value="Montreal: Canine Championship series opens" />
  </message>
  <message address="rec.cars">
    <header name="title" value="The oil shock: does it affect you?" />
  </message>
  <message address="rec.pets.dogs">
    <header name="title" value="Steroids: the ugly truth from Montreal" />
  </message>
  <message address="rec.pets.cats">
    <header name="title" value="Cat vs. dog: facts or fictions?" />
  </message>
  <message address="rec.pets.dogs">
    <header name="title" value="Montreal in chaos: winner is a cat!" />
  </message>
  <message address="rec.cars">
    <header name="title" value="Red, white, or blue: what it says about you" />
  </message>
  <message address="rec.cars">
    <header name="title" value="Parking - who, where, why: a new survey" />
  </message>
  <message address="rec.pets.cats">
    <header name="title" value="Superiority: it comes naturally" />
  </message>
</restms>

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

++++ The newsfeed subscriber

The subscriber creates a pipe on which to receive news items, and the server responds with a pipe description that includes the asynclet on which the subscriber can wait to get the next incoming message:

[[code]]
Client:
-------------------------------------------------
POST /restms/domain/default
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="fifo" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml
Location: http://host.com/restms/resource/F33D

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <pipe type="fifo" name="RESTMS_F33D" >
    <message
        href="http://host.com/restms/resource/33D1"
        async="1" />
  </pipe>
</restms>
[[/code]]

The subscriber then creates a join from its pipe to the newsfeed, by POSTing a join specification to the pipe URI.

[[code]]
Client:
-------------------------------------------------
POST /restms/resource/F33D
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <join address="rec.pets.*" feed="http://host.com/restms/feed/newsfeed" />
</restms>

Server:
-------------------------------------------------
HTTP/1.1 201 Created
Content-Type: application/restms+xml
Location: http://host.com/restms/resource/8008

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <join address="rec.pets.*" feed="http://host.com/restms/feed/newsfeed" />
</restms>
[[/code]]

The subscriber retrieves the message asynclet, and thus waits for an incoming message:

[[code]]
Client:
-------------------------------------------------
GET /restms/resource/33D1
[[/code]]

And when a news item arrives, the server sends it to the waiting subscriber:

[[code]]
Server:
-------------------------------------------------
HTTP/1.1 200 OK
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <message address="rec.pets.dogs">
    <header name="title" value="Montreal: Canine Championship series opens" />
  </message>
</restms>
[[/code]]

When the subscriber has finished, it deletes its pipe:

[[code]]
Client:
-------------------------------------------------
DELETE /restms/resource/F33D

Server:
-------------------------------------------------
HTTP/1.1 200 OK
[[/code]]

++ References

[[bibliography]]
: rfc2119 : "Key words for use in RFCs to Indicate Requirement Levels" - [http://tools.ietf.org/html/rfc2119 ietf.org]
: rfc2616 : "HTTP/1.1 Protocol Parameters" - http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html w3.org]
: amqp : "The Advanced Message Queueing Protocol" - [http://www.amqp.org amqp.org]
: coss : "Consensus Oriented Specification System" - [http://wiki.amqp.org/spec:1 wiki.amqp.org]
: rest : Roy Fielding, "Representational State Transfer (REST)" [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm www.ics.uci.edu]
: atompub : "The Atom Syndication Format" - [http://www.ietf.org/rfc/rfc4287.txt ietf.org]
: comet : "A Standards Based Approach to Comet Communication with REST" [http://cometdaily.com/2008/01/17/proposal-for-native-comet-support-for-browsers/ cometdaily.com]
[[/bibliography]]
