This document introduces RestMS, the RESTful Messaging Service.  RestMS provides web applications with enterprise-level messaging via an asynchronous RESTful interface that works over standard HTTP/HTTPS.  RestMS applications can interoperate with AMQP networks.

* Name: 7-RESTMS@wiki.amqp.org
* Version: draft/3
* Editor: Pieter Hintjens <ph@imatix.com>
* Contributors: Steve Vinoski <vinoski@ieee.org>, Brad Clements <bkc@murkworks.com>
* Resources: http://www.restms.org.

++ License

This document is licensed under the [http://wiki.amqp.org/main:intellectual-property-policy Intellectual Property Policy] of the wiki.amqp.org site.

++ Change process

This document is governed by the 1-COSS@wiki.amqp.org specification[((bibcite coss))]

++ Structure of the RestMS specification

This document is a formal specification of the resources that RestMS implements, and how they work.  These further documents form part of the overall specifications:

* The HTTP method patterns and resource document grammar that underpin RestMS are specified in the [[[spec:9|9-RESTTL@wiki.amqp.org]]] RESTful transport layer (RestTL) specifications.  A conformant RestMS implementation MUST properly implement the RestTL patterns on the RestMS resources.

* RestMS-to-AMQP interoperability is defined in the [[[spec:10|10-RESTMS-AMQP@wiki.amqp.org]]] RestMS-to-AMQP interoperability specification.  Conformant RestMS implementations MAY implement AMQP interoperability according to these specifications.

++ Language

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119[((bibcite rfc2119))].

++ Terminology

These terms are introduced by, or have specific meaning, in this specification:

* Domain - a set of resources managed by one RestMS server or virtual host.
* Feed - a destination for messages published by applications.
* Pipe - a source of messages delivered to applications.
* Join - a relationship between a pipe and a feed.
* Message - a package of data consisting of an envelope and zero or more contents.
* Content - an opaque binary payload, with a MIME type and encoding.
* Asynclet - a resource that can be retrieved before it exists, resulting in a "long poll".

++ RestMS resource types

+++ Domains

Domains follow these rules:

* A domain is a public collection of feeds and pipes and the child resources they contain.
* The server MAY implement multiple domains and MAY allow routing of messages between domains.
* Domains are configured resources: clients do not create or destroy domains.
* Domains act as namespaces for pipes and feeds.
* Client and servers must agree in advance on the domains that exist.
* RestMS servers SHOULD implement a default public domain named "default".

The URI for a domain is:

[[code]]
http://{server-name}[:{port}]/restms/domain/{domain-name}
[[/code]]

The URI for the default domain is:

[[code]]
http://{server-name}[:{port}]/restms/domain/default
[[/code]]

RestMS allows these methods on a domain URI:

* GET - retrieves the domain representation.
* POST - creates a new feed or pipe within the domain.

A domain document specifies the domain properties, and has references to all public feeds and pipes that the domain contains.  The XML format of this document is:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.restms.org/schema/restms">
  <domain title="{domain description}">
    [ <feed
        name="{feed name}"
        title="{feed description}"
        type="{feed type}"
        license="{license}"
        href="{feed URI}" /> ] ...
    [ <pipe
        name="{pipe name}"
        title="{pipe description}"
        type="{pipe type}"
        href="{pipe URI}" /> ] ...
  </domain>
</restms>
[[/code]]

The domain document does not necessarily list all feeds and pipes: clients may create these as private and thus make them inaccessible through discovery.

+++ Feeds

Feeds follow these rules:

* A feed is a //write-only// ordered stream of messages received from one or more writers.
* The order of messages in a feed is stable per writer.
* Feeds deliver messages into pipes, according to the joins defined on the feed.
* Clients can create dynamic feeds for their own use.
* To create a new feed the client POSTs a feed document to the parent domain URI.
* The server MAY implement a set of configured public feeds.
* The server SHOULD implement a default public feed called "default" of type "direct"..

RestMS allows these methods on a feed URI:

* GET - retrieves the feed.
* PUT - updates the feed.  The feed name and type cannot be modified.
* DELETE - deletes the feed.
* POST - sends a message to the feed or stage a content on the feed.

The XML specification for a feed this format:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.restms.org/schema/restms">
  <feed
      name="{feed name}"                    mandatory feed name
    [ type="{feed type}" ]                  optional type, default is "topic"
    [ title="{short title}" ]               optional title
    [ license="{license name}" ]            optional license name
    />
</restms>
[[/code]]

The feed type defines the routing semantics of the feed.  We explain the feed type semantics later.  If the client attempts to create a feed with an unknown type, the server responds with "400 Bad Request".  If the client does not specify a feed type, the type defaults to "topic".

+++ Pipes

Pipes follow these rules:

* A pipe is a //read-only// ordered stream of messages meant for a single reader.
* The order of messages in a pipe is stable only for a single feed.
* Pipes receive messages from pipes, according to the joins defined between the pipe and the feed.
* Clients MUST create pipes for their own use: all pipes are private and dynamic.
* To create a new pipe the client POSTs a pipe document to the parent domain's URI.
* The server MAY do garbage collection on unused, or overflowing pipes.

RestMS allows these methods on a pipe URI:

* GET - retrieves the pipe representation.
* DELETE - deletes the pipe.
* POST - creates a new join for the pipe.

The XML specification for a new pipe has this format:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.restms.org/schema/restms">
  <pipe
    [ type="{pipe type}" ]                  optional type, default is "fifo"
    [ title="{short title}" ]               optional title
    />
</restms>
[[/code]]

The XML description of an existing pipe has this format:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.restms.org/schema/restms">
  <pipe
      name="{pipe name}"                    server-generated hash
      type="{pipe type}"                    actual pipe type
    [ title="{short title}" ]               title, if specified
    >
    [ <join href="{join URI}" address="{address pattern}" feed="{feed URI}" /> ] ...
    [ <message href="{message URI}" address="{address literal}" /> ] ...
    [ <message href="{message URI}" async="1" /> ]
  </pipe>
</restms>
[[/code]]

The pipe type defines the routing semantics of the pipe.  We explain the pipe type semantics later.  If the client attempts to create a pipe with an unknown type, the server responds with "400 Bad Request".  If the client does not specify a pipe type, the type defaults to "fifo".

Pipes are not shareable: if more than one client accesses the same pipe, the results will be unpredictable and none of the clients will receive the full set of messages, nor any cleanly defined subset.  The proper way to distribute messages between clients (Wolfpack pattern) is to use a service or rotator feed, and a set of ondemand pipes, one per client.

Pipes on service or rotator feeds should be cached: if a client creates a new pipe each time it starts, messages can be left unprocessed (and thus lost) in unused pipes.  Clients should therefore record the URI of the pipe they are using, and attempt to use this pipe when re-starting.  If the pipe no longer exists, they should create a new pipe and record that URI.

+++ Joins

Joins follow these rules:

* Joins specify criteria by which feeds route messages into pipes.
* Joins are always dynamic and always private.
* Clients MAY create joins at runtime, after creating pipes.
* To create a new join the client POSTs a join specification to the parent pipe URI.
* The server SHOULD create a join from each new pipe to the default feed.
* If either the feed or the pipe for a join is deleted, the join is also deleted.

RestMS allows these methods on a join URI:

* GET - retrieves the join representation.
* DELETE - deletes the join.

The XML specification or description for a join has this format:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.restms.org/schema/restms">
  <join
    address="{address pattern}"             depends on feed type
    feed="{feed URI}"                       the feed to pull from
    />
</restms>
[[/code]]

The default join implements a guaranteed Housecat pattern on every pipe.  If clients attempt to delete the default join, or create other joins onto the default feed, the server MUST respond with "403 Forbidden".

+++ Messages and contents

Messages and contents are tightly coupled resources that follow these rules:

* Messages are envelopes that can optionally carry contents.
* Contents are blobs of data with a MIME type set by the sender.
* Contents MAY be embedded in the message resource OR carried as separate resources.

Message/content publication and delivery are distinct processes with no overlap.  The use of message and content resources is the only area in RestMS that deviates from the standard resource access model defined by RestTL.  Specifically, in the RestTL model a client creates and then works with a resource within the same container resource.  However, message and content resources are created in one container (feed), and retrieved from a different container (pipe).

++++ Publication

Publication works thus: the client stages zero or more contents, and then posts a message that refers to those contents.

To stage a content the client does an HTTP POST to the feed URI, providing a typed opaque binary content.  That is, the body of the POST request provides the content body, and the Content-Type: header specifies the MIME type of the content.  The server replies with (if there were no other errors) "201 Created" with the URI for the staged content in the Location: header.

[[code]]
Client                                     Server
  |                                           |
  |  1.) POST to feed URI                     |
  |      Content-type: {MIME-type}            |
  |      POST body is content                 |
  |------------------------------------------>|
  |                                           |
  |  2.) 201 Created                          |
  |      Location: Resource URI               |
  |<------------------------------------------|
  |                                           |
[[/code]]

The Content-Type: MUST not be a structured document type ("application/restms+xml", "application/restms+xml", or "text/xml").  If the Content-Type: is a structured document type, the server will interpret the POST as providing a message, not a content.

Once the client has staged the zero or more necessary contents, it publishes the message by POSTing a message specification to the feed URI.  The XML format for this specification is:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.restms.org/schema/restms">
  <message
    [ address="{address literal}" ]
    [ reply_to="{address literal}" ]
    [ <header name="{header name}" value="{header value}" /> ] ...
    [ <content href="{content URI}" ... />
    | <content type="{MIME type} encoding="{encoding}">{content value}</content> ]
  </message> ...
</restms>
[[/code]]

The specification can contain multiple message elements: clients can stage multiple contents and then publish them in a single operation.

A message specification consists of a set of properties (attributes of the message element), a set of header elements, a set of content references, and a set of embedded contents.  These work as follows:

* The address is used in routing, and has feed-specific semantics.
* The headers may used in routing, and to carry arbitrary information.
* The reply_to tells an eventual recipient where to send a reply message.
* The content hrefs refer to previously staged contents.
* The content elements, if they have an element value, hold embedded contents.
* Implementations may add other properties with implementation-defined meaning.

Clients may publish any mix of staged and embedded contents.  Implementations MAY set arbitrary limits on this.  Embedded contents are encoded either as "plain" or as "base64".

The server processes each message element by routing the message+content, using the feed semantics, and the defined joins, into zero or more pipes.  It then automatically deletes the staged contents.

If a client attempts to publish the same staged content more than once the server MUST reply with "404 Not Found", and not route the message.  If a client attempts to publish a message referring to contents that were staged to a different feed, the server MUST reply with "403 Forbidden", and not route the message.  The server SHOULD verify the content URIs of all messages in the request before routing any message in the request.

It the server successfully processes the request, it replies with "200 OK".  It does not return a Location: header nor a content body, unlike for a usual RestTL POST operation.

++++ Delivery

Delivery works thus: the client retrieves a message, then retrieves zero or more contents, and then deletes the message.

To retrieve a message the client must first have retrieved the pipe to know the message URI.  The message will often be an asynclet as defined in RestTL.  The client retrieves a message using the GET method.

The XML description of a message returned by the server has this format:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.restms.org/schema/restms">
  <message
    [ address="{address literal}" ]
    [ reply_to="{address literal}" ]
    [ feed="{originating feed URI}" ] >
    [ <header name="{header name}" value="{header value}" /> ] ...
    [ <content href="{content URI}" ... />
    | <content type="{MIME type} encoding="{encoding}">{content value}</content> ]
  </message>
</restms>
[[/code]]

This is identical to the message specification posted to a feed, with the addition of a 'feed' property.  The server SHOULD set the feed property to the name of the feed to which the message was published.

The message description contains zero or more content elements; the receiver MAY retrieve the contents which have a href URI, using separate GET methods.  The Content-Type: of the retrieved content will be the same as the Content-Type: of the published content.

During routing, the server MAY reformat staged contents as encoded, and vice-versa.  The 'type' attribute of the embedded content corresponds one-for-one to the Content-Type: header of a staged content.  Staged contents are not encoded: if a server reformats a base64-encoded content to a staged content it MUST decode the embedded content according to IETF RFC 4648 [((bibcite base64))].  Similarly, if a server reformats a staged content to an encoded content it MUST encode the content as base64 unless the content contains only plain text characters.

After it has processed a message the client MUST send a DELETE request on the message URI.  When the server deletes a message it also deletes any contents that message contains.

RestMS allows these methods on a message that is held in a pipe:

* GET - retrieves the message representation.
* DELETE - deletes the message //and all older messages// from the pipe.

RestMS allows these methods on a content that is part of a delivered message:

* GET - retrieve the content.
* DELETE - deletes the content.

++ References

[[bibliography]]
: amqp : "The Advanced Message Queueing Protocol" - [http://www.amqp.org amqp.org]
: rfc2119 : "Key words for use in RFCs to Indicate Requirement Levels" - [http://tools.ietf.org/html/rfc2119 ietf.org]
: coss : "Consensus Oriented Specification System" - [http://wiki.amqp.org/spec:1 wiki.amqp.org]
: rest : Roy Fielding, "Representational State Transfer (REST)" [http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm www.ics.uci.edu]
: brooks : Fred Brooks, "No Silver Bullet - Essence and Accidents of Software Engineering" -  [http://en.wikipedia.org/wiki/No_Silver_Bullet Wikipedia]
: digistan : The Digital Standards Organization - [http://www.digistan.org]
: base64 : "IETF RFC 4648" - [http://tools.ietf.org/html/rfc4648]
[[/bibliography]]
