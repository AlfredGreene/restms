RestMS provides web applications with enterprise-level messaging via an asynchronous RESTful interface that works over standard HTTP/HTTPS.  This document defines a generic RESTful framework for documents and methods, for RestMS implementors.

* Name: 10-RESTMS-BASE@wiki.amqp.org
* Version: draft/3
* Editor: Pieter Hintjens <ph@imatix.com>
* Contributors: Steve Vinoski <vinoski@ieee.org>, Brad Clements <bkc@murkworks.com>
* Resources: http://www.restms.org.

++ License

This document is licensed under the [http://wiki.amqp.org/main:intellectual-property-policy Intellectual Property Policy] of the wiki.amqp.org site.

++ Change process

This document is governed by the 1-COSS@wiki.amqp.org specification[((bibcite coss))]

++ Related documents

This document is part of the [[[spec:7 |RestMS specification]]].  It provides a guide to using RestMS in applications.  The specification is described in more detail by these separate documents:

* [[[spec:9 |RestMS-user]]] - guide to using RestMS in applications, for RestMS users.
* [[[spec:11|RestMS-core]]] - technical specifications of RestMS, for RestMS implementors.
* [[[spec:12|RestMS-amqp]]] - AMQP-to-RestMS interoperability specifications, for RestMS implementors.

++ Generic structured document syntax

+++ Overview

RestMS defines a generic document syntax for resources, based on these principles:

* Resources are typed, and the type names form the main element names in the document.
* A resource may, or may not, be a container for other resources depending on its type.
* The document syntax is fully neutral with respect to the resource hierarchy.  That is, when the protocol is changed to add new resources, remove resources, or modify resources, nothing in this section will change.
* There is a single root resource that contains all other resources.
* Clients can navigate the resource hierarchy with no specific knowledge except the type and URI of the root resource.
* Documents can include opaque binary resources, which themselves cannot contain further RestMS resources.

Our goals with this design are:

* To define a generic syntax that can be implemented, understood, and reused without needing specific knowledge of the RestMS resources and their semantics.
* To define a document syntax that is easily mapped to arbitrary representations including XML and JSON.  We document the use of these two representations but do not exclude others.
* To provide documents that are navigable and discoverable with mimimum prior knowledge.
* To deliver most of the benefits of structured representations (such as cheap parsing) without the cost of formalised validation.
* To allow unilateral extensibility of the resource hierarchy by server implementations.
* To keep things as simple as possible for RestMS users: this means being able to read and create RestMS documents with minimum libraries, extensions, addons, and other complexities.
* To allow for future evolution in structured data representation.

+++ Basic syntax rules

RestMS documents obey these basic rules:

* All RestMS documents have a "document root" element called "restms".
* This document root contains one or more "resource roots".
* The resource root elements contains other elements, each which can itself contain elements.
* All elements except the document root element correspond to RestMS resources, with the name of the element equal to the resource type.
* All elements except the document root may have attributes, corresponding to resource properties.
* All elements except the document root may repeat 0 or more times.

Further, for XML documents:

* The Content-type MUST be "application/restms+xml".
* The document root has a single attribute, xmlns="http://www.imatix.com/schema/restms".
* The following character MUST be escaped in attribute values:
 * " (escaped by writing &quot;)

And for JSON documents:

* The Content-type MUST be "application/restms+json".
* The following character MUST be escaped in value strings:
 * " (escaped by writing \")

Here is an example of a RestMS document in XML:

[[code]]
<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <playlist>
    <album
      artist="Echobelly"
      title="On"
      released="1995-10-17"
      summary="Underrated, bittersweet guitar rock perfection">
      <track title="Car Fiction" length="2:31" />
      <track title="King of the Kerb" length="3:59" />
      <track title="Great Things" length="3:31" />
      <track title="Natural Animal" length="3:27" />
      <track title="Go Away" length="2:44" />
      <track title="Pantyhose and Roses" length="3:26" />
      <track title="Something Hot in a Cold Country" length="4:01" />
      <track title="Four Letter Word" length="2:51" />
      <track title="Nobody Like You" length="3:52" />
      <track title="In the Year" length="3:31" />
      <track title="Dark Therapy" length="5:30" />
      <track title="Worms and Angels" length="2:38" />
    </album>
  </playlist>
</restms>
[[/code]]

The resource hierarchy in our example is:

[[code]]
playlist
    |
    o- album
        |
        o- track
[[/code]]

Here is the same document in JSON:

[[code]]
{
"restms": {
  "playlist": [ { "name":"default",
    "album": [ { "artist":"Echobelly", "title":"On", "released":"1995-10-17",
      "track": [
        { "title":"Car Fiction", "length":"2:31" },
        { "title":"King of the Kerb", "length":"3:59" },
        { "title":"Great Things", "length":"3:31" },
        { "title":"Natural Animal", "length":"3:27" },
        { "title":"Go Away", "length":"2:44" },
        { "title":"Pantyhose and Roses", "length":"3:26" },
        { "title":"Something Hot in a Cold Country", "length":"4:01" },
        { "title":"Four Letter Word", "length":"2:51" },
        { "title":"Nobody Like You", "length":"3:52" },
        { "title":"In the Year", "length":"3:31" },
        { "title":"Dark Therapy", "length":"5:30" },
        { "title":"Worms and Angels", "length":"2:38" }
      ],
      "summary":"Underrated, bittersweet guitar rock perfection" }
    ] }
  ] }
}
[[/code]]

+++ Navigation and discovery

RestMS documents use the following rule to allow navigation and discovery:

* The attribute "href", if present, holds the URI for the resource that the element represents.
* The URI for the root resource is known to both client and server by common agreement.
* The URIs for all non-root resources are generated by the server and may be stored by the client.
* URIs may be relative or absolute.

Here is an example of a client retrieving a public playlist resource using a HTTP GET method, with the server's response.  The server is at 'host.com':

[[code]]
Client:
GET /restms/playlist/default HTTP/1.1

Server:
HTTP/1.1 200 OK
Date: Mon Jan 12 12:05:01 2009
Content-Length: 440
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <playlist name="default">
    <album
        artist="Echobelly"
        title="On"
        href="http://host.com/restms/resource/A1023" />
    <album
        artist="Muse"
        title="Showbiz"
        href="http://host.com/restms/resource/A0911" />
    <album
        artist="Toumani Diabate"
        title="Djelika"
        href="http://host.com/restms/resource/A0023" />
  </playlist>
</restms>
[[/code]]

To retrieve a specific album, the client uses the URI provided by the server, for example:

[[code]]
Client:
GET /restms/resource/A1023 HTTP/1.1

Server:
HTTP/1.1 200 OK
Date: Mon Jan 12 12:05:02 2009
Content-Length: 1440
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
    <album
        artist="Echobelly"
        title="On"
        released="1995-10-17"
        summary="Underrated, bittersweet guitar rock perfection"
      <track title="Car Fiction" length="2:31"
        href="http://music.host.com/resource/A1023/1" />
      <track title="King of the Kerb" length="3:59"
        href="http://music.host.com/resource/A1023/2" />
      <track title="Great Things" length="3:31"
        href="http://music.host.com/resource/A1023/3" />
      <track title="Natural Animal" length="3:27"
        href="http://music.host.com/resource/A1023/4" />
      <track title="Go Away" length="2:44"
        href="http://music.host.com/resource/A1023/5" />
      <track title="Pantyhose and Roses" length="3:26"
        href="http://music.host.com/resource/A1023/6" />
      <track title="Something Hot in a Cold Country" length="4:01"
        href="http://music.host.com/resource/A1023/7" />
      <track title="Four Letter Word" length="2:51"
        href="http://music.host.com/resource/A1023/8" />
      <track title="Nobody Like You" length="3:52"
        href="http://music.host.com/resource/A1023/9" />
      <track title="In the Year" length="3:31"
        href="http://music.host.com/resource/A1023/10" />
      <track title="Dark Therapy" length="5:30"
        href="http://music.host.com/resource/A1023/11" />
      <track title="Worms and Angels" length="2:38"
        href="http://music.host.com/resource/A1023/12" />
    </album>
</restms>
[[/code]]

To retrieve a specific track, the client once again uses the URI provided by the server.  Note that in this case the server delivers a content of type "audio/mpeg-3", which the client should process accordingly (and not as RestMS XML or JSON):

[[code]]
Client:
GET http://music.host.com/resource/A1023/5 HTTP/1.1

Server:
HTTP/1.1 200 OK
Date: Mon Jan 12 12:05:03 2009
Content-Length: 2870112
Content-Type: audio/mpeg-3

...opaque binary content...
[[/code]]

++ Generic RESTful framework

RestMS defines a generic framework by which clients issue HTTP methods to work with server-side resources as follows:

* Clients use the GET method to retrieve the representation of a known resource.
* Clients use the POST method to create a new, dynamically named resource.
* Clients use the PUT method to edit a known resource (not to create resources).
* Clients use the DELETE method to remove a known resource.

All methods work orthogonally on all types of RestMS resources, whether those resources contain or do not contain other resources.  Not all combinations of methods and resources are meaningful, implemented, or permitted.

This framework draws heavily on the design of AtomPub[((bibcite atompub))] and that specification may be helpful as a background to the mechanics of implementing a RESTful dialog over a HTTP transport.

In this section we use XML as the document language, but the reader may note that RestMS allows a choice of representations for structured data.

+++ Resource lifecycles and visibility

RestMS distinguishes between resources that are created automatically by the server ("configured resources") and resources that are created at runtime by applications ("dynamic resources").  It also distinguishes between resources that are named and visible to all applications ("public resources") and resources that are unnamed and accessible only by a (by default) secret hash ("private resources").

The lifecycle and visibility of resources is related, as follows:

* Configured resources are always public while dynamic resources are by default private.
* Applications can modify and delete dynamic resources, if they know their URIs, while they may not modify or delete configured resources.
* The URI for a public resource is derived from its type and slug (which may be empty), while the URI for a private resource is provided by the server.
* Public resources are named, and discoverable through navigation of parent resources.  Private resources are unnamed, and undiscoverable through navigation.
* Dynamic resources may in some cases be created by the server.

The URI for a public resource is derived from the resource type and slug as follows:

[[code]]
http://{server-name}[:{port}]/restms/{resource type}/{resource slug}
[[/code]]

The URI for a private resource takes this form:

[[code]]
http://{server-name}[:{port}]/restms/resource/{resource hash}
[[/code]]

+++ Resource propagation

RestMS resources may be propagated to foreign messaging networks (particularly AMQP networks).  In this case, these rules apply:

* Public resources are propagated using the resource slug value.  It is responsibility of the client application to ensure that the values used are unique.  Implementations MAY enforce uniqueness, at the cost of interoperability.
* Private resources are propagated using the resource hash value.  It is the responsibility of the implementation to ensure that these hash values are unique.

+++ Creating a new resource

The creation of a new dynamic resource follows these rules:

* The new resource will always be the child of another resource (the 'parent') identified with a URI.
* The client creates the resource by sending a POST method on the parent URI and providing the specifications for the new resource as the POST content body.
* The client can request a public or a private resource.  Public resources are named by a Slug header, while private resources named by a server-generated hash.
* The server replies, if there was no error, with a "200 OK" or "201 Created" reply status, a Location: header that provides a URI to the new resource, and a content body that represents the created resource.

[[code]]
Client                                     Server
  |                                           |
  |  1.) POST to parent URI                   |
  |      Resource specifications              |
  |------------------------------------------>|
  |                                           |
  |  2.) 201 Created                          |
  |      Location: Resource URI               |
  |<------------------------------------------|
  |                                           |
[[/code]]

Note that the content body of a created resource may be different than the content body provided by the client: the client provides specifications for the resource, while the server provides the actual resulting resource contents.

This is the general form of a client request to create a dynamic resource:

[[code]]
POST /{parent uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
Content-Type: application/restms+xml
Content-Length: {size of content}
Slug: {name for public resource}

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type}>
    {resource specifications}
  </{resource type}>
</restms>
[[/code]]

If allowed by the resource type, and if the Slug header is specified, the new dynamic resource will be public, otherwise it will be private.  This is the general form of a server response for a created resource:

[[code]]
HTTP/1.1 201 Created
Date: {response date}
Content-Length: {size of content}
Content-Type: application/restms+xml
Location: http://{hostname}[{port}]/restms/resource/{hash}
ETag: "{resource entity tag}"

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type} name="{resource name}"...>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

Private resources are accessed through their URI.  If the POST request actually created the resource the server responds with "201 Created".  If the resource already existed, and the specifications are correct, the server responds with "200 OK".  For both cases, the server provides a Location: header with the resource's URI.  If the POST failed, the server responds with a "400 Bad Request" or other suitable reply code.

+++ Retrieving a known resource

Retrieving a known resource follows these rules:

* The client must know the URI of the resource.  If it does not know the URI of the resource, and the resource is public, it can discover this by retrieving the parent resource and examining its contents.  If the resource is private, the client must either have created the resource, or must receive the resource URI by an out-of-band communication (for example a message from an external resource management service application).
* The client retrieves the resource by sending a GET method on the resource URI.
* The client can optionally specify headers to control the caching of the resource both by itself and by proxies that sit between it and the server.  We explain caching below.
* The server either returns a "200 OK" reply with the contents of the resource, or returns a reply code indicating why it did not return the resource contents.

[[code]]
Client                                     Server
  |                                           |
  |  1.) GET to Resource URI                  |
  |------------------------------------------>|
  |                                           |
  |  2.) 200 Ok                               |
  |      Resource representation              |
  |<------------------------------------------|
  |                                           |
[[/code]]

This is the general form of a client request to retrieve a resource:

[[code]]
GET /{resource uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
[[/code]]

And this is the general form of a server response:

[[code]]
HTTP/1.1 200 OK
Date: {response date}
Content-Length: {size of content}
Content-Type: application/restms+xml
Date-Modified: {resource date and time}
ETag: "{resource entity tag}"

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type} ...>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

If the client has previously retrieved the same resource and still has that ETag, it can use the If-None-Match: header, specifying the ETag value, and/or the If-Modified-Since: to do a conditional GET:

[[code]]
GET /{resource uri} HTTP/1.1
...
If-None-Match: "{resource entity tag}"
If-Modified-Since: {resource date and time}
[[/code]]

If the resource has not changed - still has the same ETag and modification date - the server replies with a "304 Not Modified":

[[code]]
HTTP/1.1 304 Not Modified
Date: {response date}
[[/code]]

+++ Modifying a known resource

Modifying a known resource follows these rules:

* The client must know the URI of the resource.  If it does not know the URI of the resource, it can discover this by examining the contents of the parent resource.
* The client must have retrieved the resource using GET.
* The client sends new resource contents by sending a PUT method on the resource URI with a modified resource content.
* The client can optionally specify headers to control potential conflicts (two clients trying to modify the same resource at the same time).
* The server either returns a "2xx OK" reply indicating success, or returns a reply code indicating why it did not modify the resource contents.

[[code]]
Client                                     Server
  |                                           |
  |  1.) GET to Resource URI                  |
  |------------------------------------------>|
  |                                           |
  |  2.) 200 OK                               |
  |      Resource representation              |
  |<------------------------------------------|
  |                                           |
  |  3.) PUT to Resource URI                  |
  |      Modified resource representation     |
  |------------------------------------------>|
  |                                           |
  |  4.) 200 OK                               |
  |<------------------------------------------|
[[/code]]

This is the general form of a client request to modify a resource:

[[code]]
PUT /{resource uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
Content-Length: {size of content}
Content-Type: application/restms+xml

<?xml version="1.0"?>
<restms xmlns="http://www.imatix.com/schema/restms">
  <{resource type} ...>
    {resource contents}
  </{resource type}>
</restms>
[[/code]]

And this is the general form of a server response:

[[code]]
HTTP/1.1 200 OK
Date: {response date}
[[/code]]

The client can use the If-Match: and If-Unmodified-Since headers, specifying the resource's ETag value and last modification date, to do a conditional PUT:

[[code]]
PUT /{resource uri} HTTP/1.1
...
If-Match: "{resource entity tag}"
If-Unmodified-Since: {resource date and time}
[[/code]]

If the resource held by the server has the same ETag and date (and if there are no other errors), the update will continue and the server will reply with "200 OK".  If the resource has changed at the server, and thus has a different ETag and/or date, the server does not update the resource, and replies with a "412 Precondition Failed":

[[code]]
HTTP/1.1 412 Precondition Failed
Date: {response date}
[[/code]]

If the PUT request has no content (Content-Length is zero) then the server will respond, if the request was correctly handled, with "201 No Content".

+++ Deleting a known resource

Deleting a known resource follows these rules:

* The client must know the URI of the resource.  If it does not know the URI of the resource, it can discover this by examining the contents of the parent resource.
* The client sends a DELETE method on the resource URI.
* The client can optionally specify headers to control potential conflicts.
* The server either returns a "2xx OK" reply indicating success, or returns a reply code indicating why it did not delete the resource contents.

[[code]]
Client                                     Server
  |                                           |
  |  1.) DELETE to resource URI               |
  |------------------------------------------>|
  |                                           |
  |  2.) 200 OK                               |
  |<------------------------------------------|
  |                                           |
[[/code]]

This is the general form of a client request to delete a resource:

[[code]]
DELETE /{resource uri} HTTP/1.1
Host: {hostname}
User-Agent: {user agent}
Authorization: {credentials}
[[/code]]

And this is the general form of a server response when the resource is successfully deleted:

[[code]]
HTTP/1.1 200 OK
Date: {response date}
[[/code]]

If the client previously read the resource, it can can use the If-Match: header, specifying the resource's ETag value, to do a conditional DELETE:

[[code]]
DELETE /{resource uri} HTTP/1.1
...
If-Match: "{resource entity tag}"
[[/code]]

If the resource held by the server has the same ETag (and if there are no other errors), the delete will continue and the server will reply with "200 OK".  If the resource has changed at the server, and thus has a different ETag, the server does not delete the resource, and replies with a "412 Precondition Failed":

[[code]]
HTTP/1.1 412 Precondition Failed
Date: {response date}
[[/code]]

+++ MIME types

When retrieving a document through the GET method a client MAY specify which MIME types it will accept using the Accept header.  While section 14.1 of RFC 2616 (the HTTP specification) defines a sophisticated format for the Accept header, RestMS currently allows these three possibilities:

* Accept: application/restms+xml
* Accept: application/restms+json
* no Accept header, or any other value.

If there is no Accept header, or it is not one of the allowed values, then it is assumed to be "application/restms+xml".

When creating a new resource using the POST method, or when modifying an existing resource using the PUT method, the client SHOULD specify the MIME type of the document that it is sending to the browser, using the Content-Type header.  For RestMS documents this MUST be one of these two:

* Content-Type: application/restms+xml
* Content-Type: application/restms+json

For the DELETE method, neither the Accept nor the Content-Type header have any significance, and if specified by the client, MUST BE ignored by the server.

If a server does not support the structured content type requested or provided by the client, it SHOULD return a response code "501 Not Implemented.

+++ Asynchronous access via asynclets

HTTP is generally a synchronous protocol in which a client polls a server for resources.  This is undesirable in many architectures, both from a design and a performance perspective.  RestMS allows for asynchronous retrieval of resources with the concept of an "asynchronous resource instance", which we call an "asynclet".

A normal resource is identified in a parent resource by a href attribute, and other attributes:

[[code]]
    <some-type href="some-URI" ... />
[[/code]]

An asynclet has the href attribute and a second attribute 'async="1"', telling the client that this resource, though it has a URI, does not in fact yet exist:

[[code]]
    <some-type href="some-URI" async="1" />
[[/code]]

When the client retrieves an asynclet, the server waits until a resource of the right type is created, within that parent, and it then responds to the client with the contents of that new resource.

In those cases where asynclets are meaningful, and implemented, the representation for a parent resource will list all existing resources plus a single asynclet:

[[code]]
    <some-type href="some-URI-1" ... />
    <some-type href="some-URI-2" ... />
    <some-type href="some-URI-3" ... />
    <some-type href="some-URI-4" ... />
    <some-type href="some-URI-5" async="1" />
[[/code]]

When the server returns the document for an asynclet, it always defines an attribute "next" which contains the URI of a new asynclet that represents the next resource which will be created.

At any time, of course, a new resource may 'arrive' and the URI held by a client for an asynclet will then refer to a real existing resource.  This is transparent to the client except that there will be no wait when the client issues a GET on that URI.

The asynclet model gives the client full choice between a synchronous polling dialog (in which it would fetch the parent each time), or an event-driven dialog (in which case it would fetch an asynclet each time).

The asynclet design addresses a similar problem as the Comet "When-Modified-After"[((bibcite comet))] HTTP extension header does, but without extending the HTTP protocol and allowing clients to wait for specific resources within a parent resource context.

+++ Cacheing

RestMS assumes that all resources may be cached.  We define two types of cache.  First, the "end cache", is held in the browser or HTTP client layer.  Second, the "proxy cache" is a service that sits between the client and the server.

The server can allow, or disallow, both types of cache from holding content.  It does this by adding a "Cache-Control: No-cache" header to the response.

The client can inform the server or proxy cache that it has cacheable content for a resource by specifying either one of, or both of, the If-Modified-Since and If-None-Match header.  Usually, specifying both headers will give best results.

Note that if a proxy cache is enabled, clients will not be guaranteed to receive the freshest version of a resource for a GET method.  There is no mechanism to push resource updates to proxy servers.

+++ Idempotency and side-effects

The GET, PUT, and DELETE methods are idempotent: the client can safely issue these more than once.  The POST method is not idempotent and if issued more than once, will create a corresponding number of new resources.

Idempotency allows the client to safely recover from failures where it did not get a response, yet could not sure the server did not receive the request.  For example, any failure in the network, the client, or an intermediary that happens after the server receives the request but before the client receives the response.  The client recovers by simply reissuing any GET, PUT and DELETE requests that were not completed.

The GET method does not modify the state of any resource on the server.

+++ Pipelining

The client may send requests in parallel, which is called "pipelining".  RFC 2616 section 8.1.2.2 says,

> Clients SHOULD NOT pipeline requests using non-idempotent methods or non-idempotent sequences of methods (see section 9.1.2). Otherwise, a premature termination of the transport connection could lead to indeterminate results. A client wishing to send a non-idempotent request SHOULD wait to send that request until it has received the response status for the previous request.

RestMS clients MAY pipeline GET, PUT and DELETE methods, but SHOULD NOT pipeline POST methods.


++ References

[[bibliography]]
: coss : "Consensus Oriented Specification System" - [http://wiki.amqp.org/spec:1 wiki.amqp.org]
: atompub : "The Atom Syndication Format" - [http://www.ietf.org/rfc/rfc4287.txt ietf.org]
: comet : "A Standards Based Approach to Comet Communication with REST" [http://cometdaily.com/2008/01/17/proposal-for-native-comet-support-for-browsers/ cometdaily.com]
[[/bibliography]]
